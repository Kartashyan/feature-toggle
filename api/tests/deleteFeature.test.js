'use strict';

// tests for deleteFeature
// Generated by serverless-jest-plugin

const mod = require('../handler');
const { resetDb } = require('./helpers');
const db = require('../database');
const jestPlugin = require('serverless-jest-plugin');
const { features: { tableName } } = require('../config');
const lambdaWrapper = jestPlugin.lambdaWrapper;
const wrapped = lambdaWrapper.wrap(mod, { handler: 'deleteFeature' });

describe('deleteFeature', () => {
  beforeAll(() => {
    return resetDb()
  });

  // TODO: add more cases WHEN needed.
  // it('should respond with an error if requested feature does not exist in the DB', async () => {
  //   const response = await wrapped.run({
  //     pathParameters: { name: "does-not-exist" }
  //   });
  //   expect(response).toBeDefined();
  //   expect(response).toEqual(expect.objectContaining({
  //     statusCode: 200,
  //     body: JSON.stringify({ message: 'Deleted!' }),
  //   }));
  // });

  it('should delete item from db and return object with message', async () => {
    let features = [
      {
        name: 'dessert1',
        enabled: true
      },
      {
        name: 'dessert2',
        enabled: false
      },
    ];
    for (const feature of features) {
      await db.put({ TableName: tableName, Item: feature }).promise();
    }

    const response = await wrapped.run({
      pathParameters: { name: features[0].name }
    });
    const result = await db.get({ TableName: process.env.FEATURES_TABLE, Key: { name: features[0].name } }).promise();
    expect(result.Item).toBeUndefined();
    expect(response).toBeDefined();
    expect(response).toEqual(expect.objectContaining({
      statusCode: 200,
      body: JSON.stringify({ message: 'Deleted!' }),
    }));
  });
});
